"""
Graph Export - Export knowledge graph to various formats

Supports formats for:
- JSON - Universal format for any platform
- Cypher - Neo4j graph database queries
- GraphML - Standard graph exchange format
- CSV - Simple tabular format for analysis
"""

import json
import csv
from pathlib import Path
from typing import Dict, List, Any
from .knowledge_graph import CodeKnowledgeGraph


class GraphExporter:
    """
    Exports code knowledge graphs to various formats.
    """

    def __init__(self, graph: CodeKnowledgeGraph):
        """
        Initialize exporter.

        Args:
            graph: CodeKnowledgeGraph instance
        """
        self.graph = graph

    def to_json(self, output_path: str, pretty: bool = True) -> str:
        """
        Export graph to JSON format.

        Args:
            output_path: Path to save JSON file
            pretty: Whether to format JSON with indentation

        Returns:
            Path to generated JSON file
        """
        output_path = Path(output_path)

        # Collect nodes
        nodes = []
        for node_id, data in self.graph.graph.nodes(data=True):
            node_data = {
                'id': node_id,
                'type': data.get('type'),
                'name': data.get('name'),
                'source_file': data.get('source_file'),
                'metadata': {k: v for k, v in data.items()
                           if k not in ['type', 'name', 'source_file']}
            }
            nodes.append(node_data)

        # Collect edges
        edges = []
        for source, target, data in self.graph.graph.edges(data=True):
            edge_data = {
                'source': source,
                'target': target,
                'relationship': data.get('relationship'),
                'metadata': {k: v for k, v in data.items()
                           if k != 'relationship'}
            }
            edges.append(edge_data)

        # Create export structure
        export_data = {
            'graph_type': 'code_knowledge_graph',
            'version': '1.0',
            'statistics': {
                'total_nodes': len(nodes),
                'total_edges': len(edges),
                'node_types': self._count_by_type(nodes, 'type'),
                'relationship_types': self._count_by_type(edges, 'relationship')
            },
            'nodes': nodes,
            'edges': edges
        }

        # Write JSON
        if pretty:
            json_content = json.dumps(export_data, indent=2)
        else:
            json_content = json.dumps(export_data)

        output_path.write_text(json_content)

        return str(output_path)

    def to_cypher(self, output_path: str) -> str:
        """
        Export graph to Cypher queries for Neo4j.

        Args:
            output_path: Path to save Cypher file

        Returns:
            Path to generated Cypher file
        """
        output_path = Path(output_path)

        lines = [
            '// Code Knowledge Graph - Neo4j Cypher Import',
            '// Generated by RAG System',
            '',
            '// Clear existing data (optional)',
            '// MATCH (n) DETACH DELETE n;',
            '',
            '// Create indexes for performance',
            'CREATE INDEX node_id_index IF NOT EXISTS FOR (n:CodeEntity) ON (n.id);',
            'CREATE INDEX node_type_index IF NOT EXISTS FOR (n:CodeEntity) ON (n.type);',
            'CREATE INDEX node_name_index IF NOT EXISTS FOR (n:CodeEntity) ON (n.name);',
            '',
            '// Create nodes',
            ''
        ]

        # Export nodes
        for node_id, data in self.graph.graph.nodes(data=True):
            node_type = data.get('type', 'unknown')
            name = data.get('name', '').replace("'", "\\'")
            source_file = data.get('source_file', '').replace("'", "\\'")

            # Build properties
            props = [
                f"id: '{node_id}'",
                f"type: '{node_type}'",
                f"name: '{name}'",
                f"source_file: '{source_file}'"
            ]

            # Add metadata
            for key, value in data.items():
                if key not in ['type', 'name', 'source_file']:
                    if isinstance(value, str):
                        value = value.replace("'", "\\'")
                        props.append(f"{key}: '{value}'")
                    elif isinstance(value, (int, float)):
                        props.append(f"{key}: {value}")

            props_str = ', '.join(props)

            # Use node type as label
            label = node_type.capitalize()

            lines.append(
                f"CREATE (n{node_id.replace(':', '_').replace('/', '_')}:{label}:CodeEntity "
                f"{{{props_str}}});"
            )

        lines.append('')
        lines.append('// Create relationships')
        lines.append('')

        # Export edges
        for source, target, data in self.graph.graph.edges(data=True):
            relationship = data.get('relationship', 'RELATES_TO').upper()

            source_var = f"n{source.replace(':', '_').replace('/', '_')}"
            target_var = f"n{target.replace(':', '_').replace('/', '_')}"

            # Build relationship properties
            rel_props = []
            for key, value in data.items():
                if key != 'relationship':
                    if isinstance(value, str):
                        value = value.replace("'", "\\'")
                        rel_props.append(f"{key}: '{value}'")
                    elif isinstance(value, (int, float)):
                        rel_props.append(f"{key}: {value}")

            if rel_props:
                props_str = '{' + ', '.join(rel_props) + '}'
                lines.append(
                    f"MATCH ({source_var}:CodeEntity {{id: '{source}'}}), "
                    f"({target_var}:CodeEntity {{id: '{target}'}}) "
                    f"CREATE ({source_var})-[:{relationship} {props_str}]->({target_var});"
                )
            else:
                lines.append(
                    f"MATCH ({source_var}:CodeEntity {{id: '{source}'}}), "
                    f"({target_var}:CodeEntity {{id: '{target}'}}) "
                    f"CREATE ({source_var})-[:{relationship}]->({target_var});"
                )

        lines.append('')
        lines.append('// Verify import')
        lines.append('MATCH (n:CodeEntity) RETURN count(n) as node_count;')
        lines.append('MATCH ()-[r]->() RETURN count(r) as relationship_count;')

        cypher_content = '\n'.join(lines)
        output_path.write_text(cypher_content)

        return str(output_path)

    def to_graphml(self, output_path: str) -> str:
        """
        Export graph to GraphML format.

        Args:
            output_path: Path to save GraphML file

        Returns:
            Path to generated GraphML file
        """
        output_path = Path(output_path)

        lines = [
            '<?xml version="1.0" encoding="UTF-8"?>',
            '<graphml xmlns="http://graphml.graphdrawing.org/xmlns"',
            '         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"',
            '         xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns',
            '         http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd">',
            '',
            '  <!-- Attribute definitions -->',
            '  <key id="type" for="node" attr.name="type" attr.type="string"/>',
            '  <key id="name" for="node" attr.name="name" attr.type="string"/>',
            '  <key id="source_file" for="node" attr.name="source_file" attr.type="string"/>',
            '  <key id="relationship" for="edge" attr.name="relationship" attr.type="string"/>',
            '',
            '  <graph id="CodeKnowledgeGraph" edgedefault="directed">',
            ''
        ]

        # Export nodes
        for node_id, data in self.graph.graph.nodes(data=True):
            # Escape XML special characters
            def escape_xml(s):
                if s is None:
                    return ''
                return str(s).replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;')

            node_id_escaped = escape_xml(node_id)
            lines.append(f'    <node id="{node_id_escaped}">')
            lines.append(f'      <data key="type">{escape_xml(data.get("type", ""))}</data>')
            lines.append(f'      <data key="name">{escape_xml(data.get("name", ""))}</data>')
            lines.append(f'      <data key="source_file">{escape_xml(data.get("source_file", ""))}</data>')
            lines.append(f'    </node>')

        lines.append('')

        # Export edges
        edge_id = 0
        for source, target, data in self.graph.graph.edges(data=True):
            def escape_xml(s):
                if s is None:
                    return ''
                return str(s).replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;')

            source_escaped = escape_xml(source)
            target_escaped = escape_xml(target)
            relationship = escape_xml(data.get('relationship', ''))

            lines.append(f'    <edge id="e{edge_id}" source="{source_escaped}" target="{target_escaped}">')
            lines.append(f'      <data key="relationship">{relationship}</data>')
            lines.append(f'    </edge>')

            edge_id += 1

        lines.append('  </graph>')
        lines.append('</graphml>')

        graphml_content = '\n'.join(lines)
        output_path.write_text(graphml_content)

        return str(output_path)

    def to_csv(self, output_dir: str) -> Dict[str, str]:
        """
        Export graph to CSV files (nodes.csv and edges.csv).

        Args:
            output_dir: Directory to save CSV files

        Returns:
            Dictionary with paths to generated CSV files
        """
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)

        nodes_path = output_dir / 'nodes.csv'
        edges_path = output_dir / 'edges.csv'

        # Export nodes
        with open(nodes_path, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(['id', 'type', 'name', 'source_file', 'metadata'])

            for node_id, data in self.graph.graph.nodes(data=True):
                metadata = {k: v for k, v in data.items()
                          if k not in ['type', 'name', 'source_file']}
                writer.writerow([
                    node_id,
                    data.get('type', ''),
                    data.get('name', ''),
                    data.get('source_file', ''),
                    json.dumps(metadata)
                ])

        # Export edges
        with open(edges_path, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(['source', 'target', 'relationship', 'metadata'])

            for source, target, data in self.graph.graph.edges(data=True):
                metadata = {k: v for k, v in data.items() if k != 'relationship'}
                writer.writerow([
                    source,
                    target,
                    data.get('relationship', ''),
                    json.dumps(metadata)
                ])

        return {
            'nodes': str(nodes_path),
            'edges': str(edges_path)
        }

    def to_adjacency_list(self, output_path: str) -> str:
        """
        Export graph as adjacency list (simple text format).

        Args:
            output_path: Path to save adjacency list file

        Returns:
            Path to generated file
        """
        output_path = Path(output_path)

        lines = ['# Code Knowledge Graph - Adjacency List', '']

        for node_id, data in self.graph.graph.nodes(data=True):
            name = data.get('name', node_id)
            node_type = data.get('type', 'unknown')

            # Get all outgoing edges
            neighbors = []
            for source, target, edge_data in self.graph.graph.edges(node_id, data=True):
                relationship = edge_data.get('relationship', '')
                target_node = self.graph.get_node(target)
                if target_node:
                    neighbors.append(f"{relationship}:{target_node.name}")

            if neighbors:
                lines.append(f"{name} ({node_type}): {', '.join(neighbors)}")

        adj_content = '\n'.join(lines)
        output_path.write_text(adj_content)

        return str(output_path)

    def get_statistics(self) -> Dict[str, Any]:
        """
        Get detailed statistics about the graph.

        Returns:
            Dictionary with statistics
        """
        # Count nodes by type
        node_types = {}
        for _, data in self.graph.graph.nodes(data=True):
            node_type = data.get('type', 'unknown')
            node_types[node_type] = node_types.get(node_type, 0) + 1

        # Count edges by relationship
        relationships = {}
        for _, _, data in self.graph.graph.edges(data=True):
            rel_type = data.get('relationship', 'unknown')
            relationships[rel_type] = relationships.get(rel_type, 0) + 1

        # Calculate degree statistics
        in_degrees = [self.graph.graph.in_degree(node) for node in self.graph.graph.nodes()]
        out_degrees = [self.graph.graph.out_degree(node) for node in self.graph.graph.nodes()]

        return {
            'total_nodes': len(self.graph.graph.nodes()),
            'total_edges': len(self.graph.graph.edges()),
            'node_types': node_types,
            'relationship_types': relationships,
            'average_in_degree': sum(in_degrees) / len(in_degrees) if in_degrees else 0,
            'average_out_degree': sum(out_degrees) / len(out_degrees) if out_degrees else 0,
            'max_in_degree': max(in_degrees) if in_degrees else 0,
            'max_out_degree': max(out_degrees) if out_degrees else 0
        }

    def _count_by_type(self, items: List[Dict], type_key: str) -> Dict[str, int]:
        """Helper to count items by type."""
        counts = {}
        for item in items:
            item_type = item.get(type_key, 'unknown')
            counts[item_type] = counts.get(item_type, 0) + 1
        return counts
